schema {
  query: RootQuery
  mutation: RootMutation
}

input ActiveRecordReference {
  ids: [ID]
  type: String!
}

type Activity {
  id: ID!
  payload: ActivityPayload
  uuid: String!
}

type ActivityCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Activity] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Activity]
  total_entries: Int!
  total_pages: Int!
}

type ActivityFeedComment implements EventSource, Node {
  activity_feed_images: [Image]
  body: String
  commentable: ActivityFeedCommentable
  commented_own_thread: Boolean
  comments(page: Int = 1, per_page: Int = 20): ActivityFeedCommentCollection
  created_at: JSONDate
  creator: User
  custom_images: [Image]
  id: ID!
  updated_at: JSONDate
  url: String
}

type ActivityFeedCommentCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [ActivityFeedComment] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [ActivityFeedComment]
  total_entries: Int!
  total_pages: Int!
}

type ActivityFeedCommentable {
  creator_id: ID
  id: Int!
  name: String
  type: String
  url: String
}

type ActivityFeedDetails {
  image: String
  text: String
}

# Event for a feed
type ActivityFeedEvent {
  comments: [ActivityFeedComment]
  created_at: String
  creator_id: ID
  description: String
  details: ActivityFeedDetails
  event: String
  event_source: ActivityFeedEventSource
  event_source_type: String
  followed: ActivityFeedFollowed
  has_body: Boolean
  header_image: String
  id: Int!
  is_comment_event: Boolean
  is_photo_event: Boolean
  is_reportable: Boolean
  is_status_update_event: Boolean
  is_text_update: Boolean
  name: String
  url: String
}

type ActivityFeedEventCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [ActivityFeedEvent] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [ActivityFeedEvent]
  total_entries: Int!
  total_pages: Int!
}

union ActivityFeedEventSource = ActivityFeedComment | ActivityFeedGeneric | ActivityFeedPhoto | ActivityFeedUserStatusUpdate | Transactable

type ActivityFeedFollowed {
  class: String!
  id: Int!
  url: String
}

type ActivityFeedGeneric implements EventSource {
  created_at: String
  id: ID
  updated_at: String
  url: String
}

type ActivityFeedPhoto {
  created_at: String
  id: ID
  image: Image
  updated_at: String
}

type ActivityFeedUserStatusUpdate implements EventSource, Node {
  activity_feed_images: [Image]
  created_at: String
  creator: User
  custom_images: [Image]
  id: ID!
  images: [Image]
  text: String
  updated_at: String
  url: String
}

type ActivityFeedUserStatusUpdateCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [ActivityFeedUserStatusUpdate] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [ActivityFeedUserStatusUpdate]
  total_entries: Int!
  total_pages: Int!
}

scalar ActivityPayload

type ActivityStreamCollection {
  results: [Activity]
  total_entries: Int!
  total_pages: Int!
}

type AdditionalLineItem {
  additional_tax_price: Float
  additional_tax_total_rate: Float
  created_at: String!
  description: String
  id: Int!
  included_tax_price: Float
  included_tax_total_rate: Float
  name: String
  net_price: Float!
  quantity: Float!
  service_fee_guest_percent: Float
  service_fee_host_percent: Float
  service_fee_payer: Float
  service_fee_payer_cents: Float
  service_fee_receiver: Float
  service_fee_receiver_cents: Float
  total_additional_tax_price: Float
  total_additional_tax_price_cents: Float
  total_included_tax_price: Float
  total_included_tax_price_cents: Float
  total_net_price: Float!
  total_net_price_cents: Float!
  total_price: String!
  total_price_cents: Float!
  total_service_fee_payer: Float
  total_service_fee_payer_cents: Float
  total_service_fee_receiver: Float
  total_service_fee_receiver_cents: Float
  unit_price: String!
  unit_price_cents: Float!
}

# An address
type Address {
  address: String
  city: String
  country: String
  id: Int!
  iso_country_code: String
  lat: Float
  latitude: Float @deprecated(reason: "Use lat")
  lng: Float
  longitude: Float @deprecated(reason: "Use lng")
  postcode: String
  state: String
  street: String
  street_number: String
  suburb: String
}

input AggregationField {
  customization_name: String
  customization_property_name: String
  field_name: String
  name: String!
  profile_type: String
  size: Int = 200

  # sort buckets; default is by doc-count descending
  sort: AggregationSort
}

input AggregationSort {
  name: AggregationSortFieldEnum = _term
  order: AggregationSortOrderEnum = asc
}

enum AggregationSortFieldEnum {
  # document count sort
  _count

  # alpha sort
  _term
}

enum AggregationSortOrderEnum {
  # ascending
  asc

  # descending
  desc
}

type Aggregations {
  compact: JSONPayload
  raw: JSONPayload
}

type Availability {
  minute: String
  quantity: Int
}

type AvailabilityRule {
  close_hour: Int
  close_minute: Int
  days: [Int]
  id: Int!
  open_hour: Int
  open_minute: Int
}

type AvailabilityTemplate {
  availability_rules: [AvailabilityRule]
  id: Int!
  schedule_exception_rules: [ScheduleExceptionRule]
}

# Stored Bank Account
type BankAccount {
  bank_name: String
  id: ID!
  instance_client_id: ID
  name: String
  payment_method_id: ID
}

type Blog {
  enabled: Boolean
  id: ID!
  name: String
}

type BlogPost {
  author_avatar_url(version: String): String
  author_name: String
  content: String
  excerpt: String
  id: ID!
  post_path: String @deprecated(reason: "Path will be defined by the client")
  published_at: JSONDate
  title: String
}

type BlogPostCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [BlogPost] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [BlogPost]
  total_entries: Int!
  total_pages: Int!
}

# Category
type Category {
  id: Int!
  is_root: Boolean
  name: String!
  name_of_root: String
  permalink: String!
  position: Int
  slug: String!
}

type Collaboration {
  id: ID!
  transactable: Transactable
  user: User
  user_id: ID!
}

type CollaborationCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Collaboration] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Collaboration]
  total_entries: Int!
  total_pages: Int!
}

enum CollaborationFilters {
  # Approved by both owner and user
  APPROVED

  # Pending received invitations
  PENDING_RECEIVED_INVITATION

  # Pending sent invitation
  PENDING_SENT_INVITATION
}

type Comment implements Node {
  activity_feed_images: [Image]
  body: String
  commentable: ActivityFeedCommentable
  commented_own_thread: Boolean
  comments(page: Int = 1, per_page: Int = 20): CommentCollection
  created_at: JSONDate
  creator: User
  custom_images: [Image]
  id: ID!
  updated_at: JSONDate
  url: String
}

type CommentCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Comment] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Comment]
  total_entries: Int!
  total_pages: Int!
}

# A firm
type Company {
  completed_at: String
  creator: User!
  creator_id: ID
  description: String
  draft_at: String
  id: Int!
  merchant_accounts(page: Int = 1, per_page: Int = 20): MerchantAccountCollection
  name: String!
  url: String
}

# Stored Credit Card
type CreditCard {
  default_card: Boolean
  id: ID!
  instance_client_id: ID
  name: String
  payment_method_id: ID
  token: String
}

# Definition of Custom attribute
type CustomAttributeDefinition {
  attribute_type: String
  id: ID
  label: String @deprecated(reason: "Use translations")
  name: String
  valid_values: [String] @deprecated(reason: "Use constants in liquid")
}

input CustomAttributeInputType {
  name: String
  value: String
}

interface CustomAttributeInterface {
  custom_attachment(name: String!): PrivateFile
  custom_image(name: String!): EsImage
  id: ID!

  # Fetch any custom attribute by name, ex: hair_color: property(name: "hair_color")
  property(name: String!): String
  property_array(name: String!): [String]
}

# Available order for custom images
enum CustomImageOrder {
  # Date added image
  DATE
}

union Customizable = Listing | Order | Profile | User

type Customization implements CustomAttributeInterface {
  created_at: String
  custom_attachment(name: String!): PrivateFile
  custom_image(name: String!): EsImage
  customizable: Customizable
  human_name: String
  id: ID!
  name: String

  # Fetch any custom attribute by name, ex: hair_color: property(name: "hair_color")
  property(name: String!): String
  property_array(name: String!): [String]
  user: User!
}

type CustomizationCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Customization] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Customization]
  total_entries: Int!
  total_pages: Int!
}

input CustomizationInputType {
  custom_model_type_id: ID
  custom_model_type_name: ID
  customizable_id: ID
  customizable_type: String
  properties: [CustomAttributeInputType]
  title: String
  user_id: ID
}

input CustomizationSortOrder {
  # Sort by given field value
  field: String
  order: String = "asc"

  # Sort by given property value
  property: String
}

input DateRange {
  gt: String
  gte: String
  lt: String
  lte: String
}

type DayAvailability {
  availability: [Availability]!
  day: Int!
  day_name: String
}

input DefaultProfileInputType {
  onboarded_at: String
  properties: [CustomAttributeInputType]
}

# Delivery
type Delivery {
  courier: String!
  id: Int!
  pickup_date: String!
}

type EsImage {
  id: ID

  # image url, ex: thumb: url(version: "thumb")
  url(version: String = "thumb"): String
}

interface EventSource {
  url: String
}

# Activity feed
type Feed {
  events: [ActivityFeedEvent]!
  events_next_page: Int
  has_next_page: Boolean
  id: ID!
  owner_id: ID!
  owner_type: String!
}

# A attachment file
type File {
  content_type: String
  file_name: String
  name: String!
  url: String!
}

type FlashMessages {
  alert: String
  notice: String
}

input FullTextQueryField {
  name: String
  priority: Int = 1
  profile_field: String
}

input GeoBox {
  bottom: LatDegree!
  left: LngDegree!
  right: LngDegree!
  top: LatDegree!
}

input GeoBoxTopLeftBottomRight {
  bottom_right: GeoPoint
  top_left: GeoPoint
}

input GeoBoxTopRightBottomLeft {
  bottom_left: GeoPoint
  top_right: GeoPoint
}

input GeoPoint {
  lat: LatDegree!
  lng: LngDegree!
}

input GeoPointInShape {
  point: GeoPoint
}

input GeoPolygon {
  # Remember to keep right order, follow GeoJSON spec
  points: [GeoPoint]
}

input GeoQuery {
  box: GeoBox
  box_top_left_bottom_right: GeoBoxTopLeftBottomRight
  box_top_right_bottom_left: GeoBoxTopRightBottomLeft
  point_in_shape: GeoPointInShape
  polygon: GeoPolygon
  radius: GeoRadius
}

input GeoRadius {
  center: GeoPoint

  # ex. 1km, 100mi, 50yards, 2meters
  distance: String!
}

type Group {
  activity_feed_events: ActivityFeedEventCollection
  cover_photo: Image
  created_at: String
  creator: User!
  creator_id: ID
  current_address: Address
  description: String
  featured: Boolean
  gallery_photos: PhotoCollection
  group_type: String
  id: ID!
  links: LinkCollection
  members(page: Int = 1, per_page: Int = 20): UserCollection
  members_count: Int
  name: String
  photos: PhotoCollection

  # Fetch any custom attribute by name, ex: hair_color: property(name: "hair_color")
  property(name: String!): String
  property_array(name: String!): [String]!
  show_path: String! @deprecated(reason: "Use generate_url filter")
  summary: String
  transactables: TransactableCollection
  updated_at: String
}

type GroupCollaboration {
  group: Group
  id: ID!
}

type GroupCollaborationCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [GroupCollaboration] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [GroupCollaboration]
  total_entries: Int!
  total_pages: Int!
}

enum GroupCollaborationFilters {
  # Approved by both owner and user
  APPROVED

  # Pending received invitations
  PENDING_RECEIVED_INVITATION

  # Pending sent invitation
  PENDING_SENT_INVITATION
}

type GroupCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Group] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Group]
  total_entries: Int!
  total_pages: Int!
}

type HTTPRequestContext {
  # Returns a String with the last requested path including their params. /foo?bar
  current_full_path: String!
  current_path: String!

  # Returns the original request URL as a String. # => "http://www.example.com/articles?page=2"
  current_url: String!
  flash: FlashMessages
  form_authenticity_token: String!

  # Returns true if the “X-Requested-With” header contains “XMLHttpRequest” (case-insensitive),
  # which may need to be manually added depending on the choice of JavaScript libraries and frameworks.
  is_xhr: Boolean

  # Access data sent in by the user or other parameters in your controller actions
  params: ParamsObject!

  # The referer of the client
  referer: String
}

type Handler {
  filter: ActivityPayload
  id: ID!
  name: String
  targets: ActivityPayload
}

type HandlerCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Handler] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Handler]
  total_entries: Int!
  total_pages: Int!
}

# Generic image
type Image {
  filename: String!
  id: ID

  # image original height
  image_original_height: Int!

  # image original width
  image_original_width: Int!

  # image url, ex: thumb: url(version: "thumb")
  url(version: String): String!
}

# Instance
type Instance {
  id: Int!
  locations(
    # Returns the elements in the list that come after the specified global ID.
    after: String

    # Returns the elements in the list that come before the specified global ID.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): LocationConnection
  name: String!
}

type InstanceAdmin {
  instance_owner: Boolean!
  role: String!
  user: User
}

scalar JSONDate

scalar JSONPayload

# Must be within range -90.0..90.0
scalar LatDegree

type Link {
  creator: User!
  id: ID!
  image: String
  linkable: Linkable
  text: String
  url: String
}

type LinkCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Link] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Link]
  total_entries: Int!
  total_pages: Int!
}

union Linkable = Group | Transactable

type Listing {
  address: Address
  all_prices: [Int]
  categories: [Category]
  category_list(name_of_root: String): [Category]
  company: Company
  created_at: String
  creator: User
  creator_id: ID
  currency: String!
  customizations(name: String, user_id: ID, properties: [QueryCustomAttribute]): [Customization]
  deleted_at: String
  description: String
  draft: String
  featured: Boolean
  id: ID!
  name: String
  photos: [EsImage]
  pricings: [Pricing] @deprecated(reason: "Use custom attributes to store and calculate prices")

  # Fetch any custom attribute by name, ex: hair_color: property(name: "hair_color")
  property(name: String!): String
  property_array(name: String!): [String]
  slug: String!
  state: String
  summary: String
  topics: [Topic]
  type: String
  updated_at: String
}

input ListingAggregation {
  fields: [AggregationField]
  filter: QueryListing
  global: Boolean = false

  # Name of the result
  name: String
}

type ListingCollection {
  aggregations: Aggregations
  has_next_page: Boolean!
  has_previous_page: Boolean!
  results: [Listing]
  size: Int!
  total_entries: Int!
  total_pages: Int!
}

# Must be within range -180.0..180.0
scalar LngDegree

# A place
type Location {
  availability: String!
  company: Company
  creator: User!
  creator_id: ID
  description: String!
  id: Int!
  name: String!
  name_and_desc: String!
  postcode: String
  state: String
  street: String
  suburb: String
}

# The connection type for Location.
type LocationConnection {
  # A list of edges.
  edges: [LocationEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type LocationEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Location
}

type MerchantAccount {
  account_type: String!
  bank_account_number: String!
  created_at: String
  date_of_birth: String!
  first_name: String!
  id: ID!
  last_name: String!
  merchantable_id: ID
  merchantable_type: String
  payment_gateway: PaymentGateway
  state: MerchantAccountState
}

type MerchantAccountCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [MerchantAccount] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [MerchantAccount]
  total_entries: Int!
  total_pages: Int!
}

# List of states for merchant account
enum MerchantAccountState {
  # Failed merchant account
  failed

  # Pending merchant account
  pending

  # Verified merchant account
  verified

  # Voided merchant account
  voided
}

# A message in a thread
type Message implements Node {
  attachments: [File]

  # Person that wrote this message
  author: User
  body: String!
  created_at: String
  id: ID!
  is_archived(user_id: ID): Boolean!
  is_read_for_owner: Boolean!
  is_read_for_recipient: Boolean!

  # User that started conversation
  owner: User

  # User that conversation is recipient
  recipient: User
  url: String
}

type MessageCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Message] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Message]
  total_entries: Int!
  total_pages: Int!
}

# An edge in a connection.
type MessageEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Message
}

# The connection type for Message.
type MessagesConnection {
  # A list of edges.
  edges: [MessageEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An object with an ID.
interface Node {
  # ID of the object.
  id: ID!
}

type OfferAction {
  id: ID!
  pricings: [Pricing]!
}

type Order implements Node {
  additional_line_items: [AdditionalLineItem]!
  additional_tax_price: Float!
  additional_tax_price_cents: Float!
  archived_at: String
  confirmed_at: String
  conflicting_orders: [Order]
  created_at: String
  creator: User!
  currency: String!

  # Fetch any customization by name or id, ex: hair_color: customization(name: "hair_color")
  customizations(id: ID, name: String): [Customization]!
  deliveries: [Delivery]
  ends_at: String
  enquirer_confirmed_at: String
  generate_order_item_at: String
  id: ID!
  included_tax_price: Float!
  included_tax_price_cents: Float!
  lister_confirmed_at: String
  net_price: Float!
  net_price_cents: Float!
  order_items: [RecurringBookingPeriod]
  payment: Payment
  payment_subscription: PaymentSubscription
  periods: [ReservationPeriod]

  # Fetch any custom attribute by name, ex: hair_color: property(name: "hair_color")
  property(name: String!): String
  rejection_reason: String!
  service_fee_amount_guest: Float!
  service_fee_amount_guest_cents: Float!
  service_fee_amount_host: Float!
  service_fee_amount_host_cents: Float!
  starts_at: String
  state: OrderState
  subtotal_amount_cents: Float!
  time_zone: String!
  total_amount: Float!
  total_amount_cents: Float!
  total_payable_to_host: Float!
  total_payable_to_host_cents: Float!
  transactable: Transactable!
  transactable_line_items: [TransactableLineItem]!
  updated_at: String
  user: User!
}

type OrderCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Order] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Order]
  total_entries: Int!
  total_pages: Int!
}

# The connection type for Order.
type OrderConnection {
  # A list of edges.
  edges: [OrderEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  total_count: Int
}

# Order direction
enum OrderDirection {
  # Asc
  ASC

  # Desc
  DESC
}

# An edge in a connection.
type OrderEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Order
}

input OrderInputType {
  state_event: String
  transactable_line_items: [TransactableLineItemInputType]
}

input OrderItemInputType {
  state_event: String
}

# List of available states for Order
enum OrderState {
  # Order which has been archived. In theory this and completed should be the same.
  archived

  # Order which has been cancelled by Enquirer.
  cancelled_by_guest

  # Order which has been cancelled by Lister.
  cancelled_by_host

  # Order which has been checked out, confirmed and now is completed.
  completed

  # Order which has been checkouted out and was confirmed by lister.
  confirmed

  # Order which has expired due to not being confirmed by Lister within given time.
  expired

  # Order which has not been checked out yet.
  inactive

  # Order which has become overdued (not paid until the present time).
  overdued

  # Order which has been checked out but has been rejected instead of being confirmed.
  rejected

  # Order which has been checked out and is pending lister's manual confirmation.
  unconfirmed
}

input OrdersSort {
  # Sort by given field value
  field: OrdersSortFields = starts_at
  order: OrderDirection = DESC
}

# List of available fields you can sort by
enum OrdersSortFields {
  # Order creation
  created_at

  # Booking date
  starts_at
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

input PaginationParams {
  page: Int = 1
  per_page: Int = 10
}

scalar ParamsObject

type Payment {
  additional_tax_price: Float!
  additional_tax_price_cents: Float!
  company: Company
  created_at: String
  currency: String!
  direct_charge: Boolean
  external_id: String
  failed_at: String
  id: ID!
  included_tax_price: Float!
  included_tax_price_cents: Float!
  paid_at: String
  payable_id: Int!
  payable_type: String!
  payer: User!
  payment_gateway: PaymentGateway
  payment_gateway_fee_cents: Float!
  payment_method: PaymentMethod
  service_fee_amount_guest: Float!
  service_fee_amount_host: Float!
  state: PaymentState
  subtotal_amount: Float!
  total_amount: Float!
  total_amount_cents: Float!
}

input PaymentAmountInputType {
  additional_tax_price: Float!
  currency: String!
  included_tax_price: Float!
  service_fee_amount_guest: Float!
  service_fee_amount_host: Float!
  subtotal_amount: Float!
  total_amount: Float!
}

type PaymentCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Payment] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Payment]
  total_entries: Int!
  total_pages: Int!
}

type PaymentGateway {
  current_mode_publishable_key: String
  id: ID!
  live_active: Boolean
  live_publishable_key: String
  payment_methods(payment_method_type: [PaymentMethodType]): [PaymentMethod]
  test_active: Boolean
  test_publishable_key: String
  type: String
}

# List modes of Payment Gateway
enum PaymentGatewayMode {
  # Uses live account, all transactions are charged
  live

  # Uses test account, no transactons are actually charged
  test
}

# List of available types of Payment Gatweways
enum PaymentGatewayType {
  BraintreeMarketplacePaymentGateway
  BraintreePaymentGateway
  ManualPaymentGateway
  PaypalExpressChainPaymentGateway
  PaypalExpressPaymentGateway
  PaypalPaymentGateway
  StripeConnectPaymentGateway
  StripePaymentGateway
}

input PaymentInputType {
  amount: PaymentAmountInputType
  direct_charge: Boolean
  paid_at: String
}

type PaymentMethod {
  active: Boolean
  environment: String
  id: ID!
  key: String
  payment_gateway: PaymentGateway
  payment_method_type: PaymentMethodType!
}

# List of available types of Payment Methods
enum PaymentMethodType {
  ach
  credit_card
  express_checkout
  free
  manual
  nonce
  remote
}

# List of available modes for Payment
enum PaymentMode {
  # Live mode
  live

  # Test mode
  test
}

# List of available states for Payment
enum PaymentState {
  # Authorized payment
  authorized

  # Failed payment
  failed

  # Payment has been made
  paid

  # Pending payment
  pending

  # Payment has been refunded
  refunded

  # Voided payment
  voided
}

type PaymentSubscription {
  expired_at: String
  id: ID!
}

type Photo {
  creator: User!
  id: ID
  image: Image
}

type PhotoCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Photo] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Photo]
  total_entries: Int!
  total_pages: Int!
}

type Pricing {
  currency: String!
  id: Int!
  max_price: String
  min_price: String
  number_of_units: Int!
  price: Float!
  price_cents: Int!
  transactable_type_pricing: TransactableTypePricing
  unit: String!
}

# A attachment file, to retrieve url please call /api/user/custom_attachments/:id
type PrivateFile {
  content_type: String
  created_at: String
  file_name: String
  id: ID
  size_bytes: Int
  url: String
}

# A profile
type Profile implements CustomAttributeInterface {
  approved: Boolean
  availability_template: AvailabilityTemplate
  category_list(name_of_root: String): [Category]
  custom_attachment(name: String!): PrivateFile
  custom_image(name: String!): EsImage
  customizations(name: String!, user_id: ID): [Customization]
  enabled: Boolean!
  id: ID!
  onboarded_at: String
  profile_type: String!

  # Fetch any custom attribute by name, ex: hair_color: property(name: "hair_color")
  property(name: String!): String
  property_array(name: String!): [String]
}

input Query {
  fields: [FullTextQueryField]
  keyword: String
  operator: String = "AND"
}

input QueryBoundingBoxCoordinates {
  nx: String!
  ny: String!
  sx: String!
  sy: String!
}

input QueryCategory {
  id: Int
  ids: [Int]
  name_of_root: String
  value: String
  values: [String]
}

input QueryCustomAttribute {
  # Set it when you want to exclude value/values/range from results
  exclude: Boolean = false
  exists: Boolean
  name: String!
  range: Range
  value: String
  values: [String]
}

input QueryCustomization {
  id: ID
  name: String
  parameterized_name: String

  # Need to narrow profiles by profile_type
  properties: [QueryCustomAttribute]
  user_id: ID
}

input QueryListing {
  address: QueryListingLocation
  categories: [QueryCategory]
  category_ids: QueryOptionList
  created_at: DateRange
  creator_id: ID
  custom_attributes: [QueryCustomAttribute]
  customizations: [QueryCustomization]
  featured: Boolean
  has_creator: Boolean
  id: ID
  ids: [ID]
  is_deleted: Boolean
  is_draft: Boolean
  is_enabled: Boolean
  location: QueryListingLocation
  name: String
  properties: [QueryCustomAttribute]
  slug: String
  state: String
  states: [String]
  topics: [QueryTopic]
  transactable_type: QueryTransactableType
}

input QueryListingLocation {
  bounding_box: QueryBoundingBoxCoordinates
  city: String
  coords: QueryPointCoordinates
  country: String
  exists: Boolean
  postcode: String
  state: String
  street: String
  suburb: String
}

input QueryOptionList {
  operator: String = "AND"
  options: [String]!
}

input QueryPointCoordinates {
  lat: String!
  lng: String!
}

input QueryTopic {
  ids: [Int]
  name: String
}

input QueryTransactableType {
  id: Int
  ids: [Int]
  name: String
  names: [String]
}

input QueryUser {
  address: QueryListingLocation
  created_at: DateRange
  customizations: [QueryCustomization]
  external_id: ID
  first_name: String
  is_banned: Boolean = false
  is_deleted: Boolean = false
  is_verified: Boolean
  last_name: String
  middle_name: String
  name: String
  profiles: [QueryUserProfile]
  tags: [String]
}

input QueryUserProfile {
  address: QueryListingLocation
  categories: [QueryCategory]
  category_ids: QueryOptionList
  custom_attributes: [QueryCustomAttribute]
  customizations: [QueryCustomization]
  is_deleted: Boolean
  is_enabled: Boolean
  is_onboarded: Boolean
  location: QueryListingLocation
  name: String
  onboarded_at: DateRange
  profile_type: String
  profile_types: [String]

  # Need to narrow profiles by profile_type
  properties: [QueryCustomAttribute]
}

input Range {
  gt: String
  gte: String
  lt: String
  lte: String
}

type RecurringBookingPeriod {
  comment: String
  currency: String
  ends_at: String
  host_additional_charges_cents: Int
  id: ID!
  order: Order!
  paid_at: String
  period_end_date: String
  period_start_date: String
  rejection_reason: String
  service_additional_charges_cents: Int
  service_fee_amount_guest_cents: Int
  service_fee_amount_host_cents: Int
  starts_at: String
  state: String
  subtotal_amount_cents: Int
  total_amount: String
  total_amount_cents: Int
  total_payable_to_host_cents: Int
  transactable_line_items: [TransactableLineItem]
}

type ReservationPeriod {
  date: String!
  end_minute: Int
  id: Int!
  recurring_frequency: Int
  recurring_frequency_unit: String
  reservation: Order!
  start_minute: Int
}

type Review {
  comment: String!
  created_at: String!
  enquirer: User!
  id: Int!
  lister: User!
  rating: Int!
}

type RootMutation {
  # destroys credit card
  credit_card_delete(id: ID!, form_configuration_name: String!): CreditCard

  # Creates customization
  customization_create(form_configuration_name: String!, customization: CustomizationInputType!): Customization

  # Remove a customization
  customization_delete(id: ID!, form_configuration_name: String!): Customization

  # Updates a customization
  customization_update(id: ID!, form_configuration_name: String!, customization: CustomizationInputType!): Customization

  # Updates an order item
  order_item_update(id: ID!, form_configuration_name: String!, order_item: OrderItemInputType!): RecurringBookingPeriod

  # Updates a order
  order_update(id: ID!, form_configuration_name: String!, order: OrderInputType!): Order

  # Charges payment
  payment_charge(id: ID!): Payment

  # Creates payment based on payment subscription
  payment_create(form_configuration_name: String!, payment: PaymentInputType, payment_subscription_id: ID!): Payment

  # Updates payment based on payment subscription
  payment_update(form_configuration_name: String!, payment: PaymentInputType, id: ID!): Payment

  # Remove transactable line item
  transactable_line_item_delete(id: ID!): TransactableLineItem

  # Updates a transactable
  transactable_update(id: ID!, form_configuration_name: String!, transactable: TransactableInputType!): Transactable

  # Sign In User
  user_session_create(email: String!, password: String!, form_configuration_name: String!): Session

  # Updates current_user
  user_update(form_configuration_name: String!, user: UserInputType!): User
}

# Root query for schema
type RootQuery {
  activities(page: Int = 1, per_page: Int = 20, ids: [ID], uuids: [String]): ActivityCollection
  blog_posts(page: Int = 1, per_page: Int = 20, tags: String): BlogPostCollection
  categories(name_of_root: String): [Category]
  comments(
    commentables: [ActiveRecordReference]
    ids: [ID]
    page: Int = 1
    paginate: PaginationParams
    per_page: Int = 20

    # A Unix timestamp
    since: Int
  ): CommentCollection
  company(id: ID): Company
  credit_cards(id: ID, user_id: ID, payment_method_id: ID): [CreditCard]!
  current_user: User
  custom_attribute_definition(name: String!): CustomAttributeDefinition
  custom_images(page: Int = 1, per_page: Int = 20, paginate: PaginationParams, ids: [ID]): PhotoCollection!
  customization(id: ID, name: String): Customization
  customizations(page: Int = 1, per_page: Int = 20, sort: [CustomizationSortOrder], id: ID, ids: [ID], user_id: ID, user_ids: [ID], name: String, customizable_type: String, customizable_id: ID, customizable_ids: [ID], properties: [QueryCustomAttribute], created_at: DateRange): CustomizationCollection
  customizations_old(id: [ID], user_id: ID, name: String, customizable_type: String, customizable_id: ID, properties: [QueryCustomAttribute], sort: [CustomizationSortOrder]): [Customization]! @deprecated(reason: "Use customizations with simple pagination")
  feed(object_id: ID!, object_type: String!, include_user_feed: Boolean, page: Int): Feed!
  feed_comments(
    page: Int = 1
    paginate: PaginationParams
    per_page: Int = 20

    # A Unix timestamp
    since: Int
  ): ActivityFeedCommentCollection
  groups(ids: [ID], id: ID, group_types: [String], page: Int = 1, per_page: Int = 20): GroupCollection!
  handlers(page: Int = 1, per_page: Int = 20): HandlerCollection
  instance: Instance
  instance_admins(role: String, instance_owner: Boolean): [InstanceAdmin]
  links(ids: [ID], page: Int = 1, per_page: Int = 20): LinkCollection!
  listings(
    aggregations: [ListingAggregation]

    # Geo search
    geo_query: GeoQuery
    listing: QueryListing
    page: Int = 1
    per_page: Int = 20

    # Fulltext search
    query: Query
    sort: [SortOrder]
  ): ListingCollection
  location(id: ID!): Location
  locations: [Location]!
  login_providers: [String]
  merchant_accounts(page: Int = 1, per_page: Int = 25, created_at: DateRange, payment_gateway_id: ID, state: [MerchantAccountState], test: Boolean): MerchantAccountCollection
  message(id: ID): Message
  messages(
    # Returns the elements in the list that come after the specified global ID.
    after: String

    # Returns the elements in the list that come before the specified global ID.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): MessagesConnection @deprecated(reason: "Use messages: messages_new{}")
  messages_new(page: Int = 1, ids: [ID], per_page: Int = 20, created_at: DateRange, author_id: ID, thread_recipient_id: ID): MessageCollection
  order(id: ID, user_id: ID, transactable_id: ID, creator_id: ID, archived: Boolean, state: [OrderState]): Order
  orders(
    # Returns the elements in the list that come after the specified global ID.
    after: String
    archived: Boolean

    # Returns the elements in the list that come before the specified global ID.
    before: String
    creator_id: ID

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    reviewable: Boolean
    state: [OrderState]
    transactable_ids: [ID]
    user_id: ID
  ): OrderConnection @deprecated(reason: "Use orders_new with simple pagination")
  orders_new(page: Int = 1, per_page: Int = 20, sort: [OrdersSort], user_id: ID, creator_id: ID, archived: Boolean, state: [OrderState], reviewable: Boolean, transactable_ids: [ID], created_at: DateRange): OrderCollection
  payment(id: ID, payable_id: ID, payable_type: String): Payment
  payment_gateways(
    # If True, return gateways by a mode set in Instance Admin, default true.
    for_current_mode: Boolean
    mode: PaymentGatewayMode
    payment_method_active: Boolean
    payment_method_type: [PaymentMethodType]
    type: [PaymentGatewayType]
  ): [PaymentGateway]
  payment_subscription(subscriber_id: ID!, subscriber_type: String!): PaymentSubscription
  payments(page: Int = 1, per_page: Int = 25, created_at: DateRange, payment_gateway_id: ID, transferred: String, state: [PaymentState], mode: [PaymentMode]): PaymentCollection
  people(
    aggregations: [ListingAggregation]

    # Geo search
    geo_query: GeoQuery
    page: Int = 1
    per_page: Int = 20

    # Fulltext search
    query: Query
    sort: [SortOrder]
    user: QueryUser
  ): UserListingCollection
  photos(
    exclude_ids: [ID]
    ids: [ID]
    page: Int = 1
    paginate: PaginationParams
    per_page: Int = 20

    # A Unix timestamp
    since: Int
  ): PhotoCollection!
  recurring_booking_period(id: ID): RecurringBookingPeriod
  request: HTTPRequestContext
  seo_keywords(keywords: [String]!, source: String!, page: Int = 1, per_page: Int = 20): SeoKeywordCollection
  streams(page: Int = 1, per_page: Int = 20, feed_type: String!, feed_id: ID, feed_name: String): ActivityStreamCollection
  tags: [Tag]
  topics(
    arbitrary_order: [String]

    # Filter featured topics
    featured: Boolean
    ids: [ID]
    page: Int = 1
    per_page: Int = 20

    # Fulltext search
    query: TopicsQuery
  ): TopicCollection!
  topics_old(filters: [TopicFilter], ids: [ID], take: Int, arbitrary_order: [String]): [Topic]! @deprecated(reason: "Use topics with simple pagination")
  transactable(
    creator_id: ID
    id: ID

    # Slug of the transactable
    slug: String
  ): Transactable!
  transactable_type(
    id: ID

    # Name of Transactable Type
    name: String
  ): TransactableType
  transactable_types(
    # List of ids
    ids: [ID]

    # List of names
    names: [String]
  ): [TransactableType]
  transactables(
    creator_id: ID
    filters: [TransactableFilter]

    # List of ids
    ids: [ID]
    listing_type_id: ID
    page: Int = 1
    paginate: PaginationParams
    per_page: Int = 20

    # A Unix timestamp
    since: Int
    state: [String]
  ): TransactableCollection! @deprecated(reason: "Use `listings` endpoint")
  user(id: ID, slug: String, email: String, external_id: String): User
  user_status_updates(ids: [ID], page: Int = 1, per_page: Int = 20): ActivityFeedUserStatusUpdateCollection!
  users(page: Int = 1, per_page: Int = 20, filters: [UserFilter], take: Int, ids: [ID], first_name: [String], last_name: [String], featured: Boolean, external_ids: [String], is_deleted: Boolean = false, is_verified: Boolean, email: String): [User]! @deprecated(reason: "Use `people` endpoint")
  wish_list_items(user_id: ID): [WishListItem]!
}

type ScheduleExceptionRule {
  duration_range_end: String!
  duration_range_start: String!
  id: Int!
}

type SeoData {
  highlighted: String!
  id: String!
  slug: String!
  snippet: String!
  url: String!
}

type SeoKeyword {
  category: String!
  category_url: String!
  default_page_meta_description: String!
  full_keyword_match_score: Int!
  listings(page: Int = 1, per_page: Int = 20, listing: QueryListing = {}): ListingCollection
  name: String!
  related_keywords(
    page: Int = 1
    per_page: Int = 20

    # available types: "similar" and "popular"
    type: String!
  ): SeoKeywordCollection
  related_keywords_seo_data(
    # available types: "similar" and "popular"
    type: String!
  ): [SeoData]
  slug: String!
  transactable_seo_data: [SeoData]
  transactables(page: Int = 1, per_page: Int = 20): TransactableCollection
  updated_at: JSONDate!
  url: String!
}

type SeoKeywordCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [SeoKeyword] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [SeoKeyword]
  total_entries: Int!
  total_pages: Int!
}

# A session
type Session {
  email: String!
  password: String!
}

input SortByFieldOrder {
  # Sort by this field, example: "id".
  field_name: String

  # Sort by provided values, example: [109, 903]. Full example: If
  # :field_name="id" and :values=[109, 903], Listing#109 will be 1st, Listing#903
  # will be 2nd, and then the rest.
  values: [String]
}

input SortOrder {
  # Sort by given field.
  field: SortByFieldOrder
  name: String
  order: String = "asc"
  profile_field: String
  profile_type: String
}

# A tag
type Tag {
  name: String!
  slug: String!
}

# A conversation thread
type Thread {
  id: ID!
  is_read: Boolean
  last_message: Message
  messages: [Message]
  participant: User
  thread_context_id: ID
  url: String
}

type TimeBasedBooking {
  availability_template: AvailabilityTemplate
  id: Int!
  minimum_booking_minutes: Int!
  pricings: [Pricing]!
}

# A topic
type Topic {
  background_style: String! @deprecated(reason: "Use cover_photo{ url(version: \"medium\") }")
  background_style_big: String! @deprecated(reason: "Use cover_photo{ url(version: \"big\") }")
  cover_photo: Image @deprecated(reason: "Not supported")
  description: String!
  feed_followers: UserCollection @deprecated(reason: "Not supported")
  id: Int!
  is_followed(follower_id: ID): Boolean! @deprecated(reason: "Will work only on users")
  listing_image_url: String! @deprecated(reason: "Use \"listings\"")
  name: String!
  show_url: String! @deprecated(reason: "Use custom pages")
}

type TopicCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Topic] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Topic]
  total_entries: Int!
  total_pages: Int!
}

# Available filters
enum TopicFilter {
  # Featured users
  FEATURED
}

input TopicsQuery {
  keyword: String
  operator: String = "AND"
}

type Transactable {
  address: String
  approved_collaborators(page: Int = 1, per_page: Int = 20): UserCollection
  categories: [TransactableCategory]
  collaborations(page: Int = 1, per_page: Int = 20, filters: [CollaborationFilters]): CollaborationCollection
  comments(page: Int = 1, per_page: Int = 20, paginate: PaginationParams): ActivityFeedCommentCollection
  company: Company!
  cover_photo: Image
  cover_photo_thumbnail_url: String @deprecated(reason: "Use cover_photo { url(version: \"thumb\") }")
  cover_photo_url: String @deprecated(reason: "Use cover_photo{ url }")
  created_at: String
  creator: User!
  creator_id: ID
  currency: String!

  # Fetch images for photo custom attribute by name,
  #               ex: cover_images: custom_attribute_photo(name: "cover_image")
  #               by default they are ordered by DATE
  custom_attribute_photos(name: String!, order: CustomImageOrder, order_direction: OrderDirection): [Image]!

  # Fetch any customization by name or id, ex: hair_color: customization(name: "hair_color")
  customizations(id: ID, name: String, user_id: ID): [Customization]!
  day_availability(date: String!, step: Int!): [Availability]!
  description: String
  draft: String
  followers(page: Int = 1, per_page: Int = 20): UserCollection
  formatted_address: String
  id: ID!
  is_followed(follower_id: ID): Boolean!
  is_seeking_collaborators: Boolean
  latitude: String
  links(page: Int = 1, per_page: Int = 20): LinkCollection
  location: Location
  location_id: ID
  longitude: String
  name: String
  offer_action: OfferAction
  orders(
    page: Int = 1
    per_page: Int = 20
    state: String

    # ID of user that created the order
    user_id: ID
  ): [Order]!
  photo_url: String
  photos: [Photo] @deprecated(reason: "Use custom_attribute_photos")
  pricings: [Pricing] @deprecated(reason: "Use custom attributes to store and calculate prices")

  # Fetch any custom attribute by name, ex: hair_color: property(name: "hair_color")
  property(name: String!): String
  property_array(name: String!): [String]!
  show_path: String! @deprecated(reason: "Use generate_url filter")
  slug: String!
  state: String
  summary: String
  time_based_booking: TimeBasedBooking
  time_zone: String
  topics(page: Int = 1, per_page: Int = 20): TopicCollection
  updated_at: String
  url: String @deprecated(reason: "Use generate_url filter")
  week_availability(step: Int!): [DayAvailability]!
}

type TransactableCategory {
  children: [TransactableCategory]!
  id: Int!
  name: String!
}

type TransactableCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [Transactable] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [Transactable]
  total_entries: Int!
  total_pages: Int!
}

# Available filters
enum TransactableFilter {
  # Active transactables
  ACTIVE

  # Featured transactables
  FEATURED
}

input TransactableInputType {
  state_event: String
}

type TransactableLineItem {
  additional_tax_price: Float
  additional_tax_total_rate: Float
  created_at: String!
  description: String
  id: Int!
  included_tax_price: Float
  included_tax_total_rate: Float
  name: String
  net_price: Float!
  quantity: Float!
  reviews(user_id: ID): [Review]!
  service_fee_guest_percent: Float
  service_fee_host_percent: Float
  service_fee_payer: Float
  service_fee_payer_cents: Float
  service_fee_receiver: Float
  service_fee_receiver_cents: Float
  total_additional_tax_price: Float
  total_additional_tax_price_cents: Float
  total_included_tax_price: Float
  total_included_tax_price_cents: Float
  total_net_price: Float!
  total_net_price_cents: Float!
  total_price: String!
  total_price_cents: Float!
  total_service_fee_payer: Float
  total_service_fee_payer_cents: Float
  total_service_fee_receiver: Float
  total_service_fee_receiver_cents: Float
  unit_price: String!
  unit_price_cents: Float!
}

input TransactableLineItemInputType {
  additional_tax_total_rate: Float
  included_tax_total_rate: Float
  name: String
  quantity: Float
  service_fee_guest_percent: Float
  service_fee_host_percent: Float
  unit_price: Float!
}

type TransactableType {
  id: ID!
  name: String!
}

type TransactableTypePricing {
  id: Int!
  service_fee_guest_percent: Float!
  service_fee_host_percent: Float!
}

# A user
type User {
  avatar: EsImage
  avatar_url_big: String @deprecated(reason: "Use avatar{}")
  avatar_url_bigger: String @deprecated(reason: "Use avatar{}")
  avatar_url_thumb: String @deprecated(reason: "Use avatar{}")
  bank_accounts(payment_method_id: ID): [BankAccount]
  collaborations(page: Int = 1, per_page: Int = 20, filters: [CollaborationFilters]): CollaborationCollection
  companies: [Company]
  country_name: String
  cover_photo: EsImage
  created_at: String
  credit_cards(payment_method_id: ID): [CreditCard]
  current_address: Address

  # Fetch images for photo custom attribute by name,
  #             ex: cover_images: custom_attribute_photo(name: "cover_image")
  #             by default they are ordered by DATE
  custom_attribute_photos(name: String!, order: CustomImageOrder, order_direction: OrderDirection): [Image]! @deprecated(reason: "Fetch custom_attribute_photos directly from profile")
  customizations(
    name: String

    # ID of user that created customization
    user_id: ID
  ): [Customization]
  display_location: String @deprecated(reason: "We will introduce custom-address")
  email: String!
  external_id: String
  first_name: String
  followers(page: Int = 1, per_page: Int = 20): UserCollection
  group_collaborations(page: Int = 1, per_page: Int = 20, filters: [GroupCollaborationFilters]): GroupCollaborationCollection
  id: ID!
  is_followed(follower_id: ID): Boolean!
  is_instance_admin: Boolean!
  last_name: String
  middle_name: String
  mobile_number: String
  name: String
  name_with_affiliation: String! @deprecated(reason: "Useless")
  phone: String
  profile(profile_type: String!): Profile
  profile_path: String! @deprecated(reason: "Use generate_url filter")

  # Fetch any property of given kind by name, ex: bio: profile_property(profile_type: "buyer", name: "bio")
  profile_property(name: String!, profile_type: String!): String

  # Fetch any custom attribute by name, ex: hair_color: property(name: "hair_color")
  property(name: String!): String @deprecated(reason: "Fetch custom_attribute directly from profile")

  # Review about a user as seller
  reviews: [Review]!
  seller_average_rating: Int! @deprecated(reason: "Everyone has custom profiles")
  slug: String!
  thread(id: ID): Thread
  threads(take: Int): [Thread]!
  transactables: [Transactable]
  updated_at: String
  verified_at: String
}

type UserCollection {
  current_page: Int!
  has_next_page: Boolean!
  has_previous_page: Boolean!
  items: [User] @deprecated(reason: "Use \"results\"")
  per_page: Int!
  results: [User]
  total_entries: Int!
  total_pages: Int!
}

# Available filters
enum UserFilter {
  # Featured users
  FEATURED
}

input UserInputType {
  profiles: [UserProfileInputType]
}

type UserListing {
  avatar: EsImage
  banned_at: String
  blog: Blog
  created_at: String
  current_address: Address
  customizations(
    name: String

    # ID of user that created customization
    user_id: ID
  ): [Customization]
  deleted_at: String
  email: String!
  external_id: ID
  first_name: String
  id: ID!
  last_name: String
  middle_name: String
  name: String!
  onboarded_at: String
  profile(profile_type: String!): Profile
  slug: String
  tag_list: [Tag]
  updated_at: String
  verified_at: String
}

type UserListingCollection {
  aggregations: Aggregations
  has_next_page: Boolean!
  has_previous_page: Boolean!
  results: [UserListing]
  size: Int!
  total_entries: Int!
  total_pages: Int!
}

input UserProfileInputType {
  name: String
  values: DefaultProfileInputType
}

type WishListItem {
  id: ID!
  wishlistable: Wishlistable
}

union Wishlistable = Location | Transactable | User
